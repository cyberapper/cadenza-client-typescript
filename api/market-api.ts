/* tslint:disable */
/* eslint-disable */
/**
 * Algo724 Cadenza Fermata API
 * OpenAPI Specification for Algo724 Cadenza Fermata API  ## API Resources - <a href=\"/postman-collection.json\" download=\"cadenza-postman-collection.json\">Download Postman Collection</a>
 *
 * The version of the OpenAPI document: 3.0.1
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import type { Configuration } from '../configuration';
import type { AxiosPromise, AxiosInstance, RawAxiosRequestConfig } from 'axios';
import globalAxios from 'axios';
// Some imports not used depending on template conditions
// @ts-ignore
import { DUMMY_BASE_URL, assertParamExists, setApiKeyToObject, setBasicAuthToObject, setBearerAuthToObject, setOAuthToObject, setSearchParams, serializeDataIfNeeded, toPathString, createRequestFunction, replaceWithSerializableTypeIfNeeded } from '../common';
// @ts-ignore
import { BASE_PATH, COLLECTION_FORMATS, type RequestArgs, BaseAPI, RequiredError, operationServerMap } from '../base';
// @ts-ignore
import type { DeleteMarketInstrument200Response } from '../models';
// @ts-ignore
import type { DeleteMarketInstrumentRequest } from '../models';
// @ts-ignore
import type { DeleteMarketSecurity200Response } from '../models';
// @ts-ignore
import type { DeleteMarketSecurityRequest } from '../models';
// @ts-ignore
import type { DisableMarketInstrumentRequest } from '../models';
// @ts-ignore
import type { EnableMarketInstrument200Response } from '../models';
// @ts-ignore
import type { EnableMarketInstrumentRequest } from '../models';
// @ts-ignore
import type { GetMarketOrderBook200Response } from '../models';
// @ts-ignore
import type { InstrumentStatus } from '../models';
// @ts-ignore
import type { ListMarketInstruments200Response } from '../models';
// @ts-ignore
import type { ListMarketOrderBooks200Response } from '../models';
// @ts-ignore
import type { ListMarketSecurities200Response } from '../models';
// @ts-ignore
import type { ListMarketVenues200Response } from '../models';
// @ts-ignore
import type { Root400Response } from '../models';
// @ts-ignore
import type { Root401Response } from '../models';
// @ts-ignore
import type { Root403Response } from '../models';
// @ts-ignore
import type { Root404Response } from '../models';
// @ts-ignore
import type { Root500Response } from '../models';
// @ts-ignore
import type { SecurityType } from '../models';
// @ts-ignore
import type { SyncMarketInstruments200Response } from '../models';
// @ts-ignore
import type { SyncMarketInstrumentsRequest } from '../models';
// @ts-ignore
import type { SyncMarketSecuritiesRequest } from '../models';
// @ts-ignore
import type { Venue } from '../models';
/**
 * MarketApi - axios parameter creator
 */
export const MarketApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Delete a market instrument
         * @summary Delete market instrument
         * @param {DeleteMarketInstrumentRequest} [deleteMarketInstrumentRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteMarketInstrument: async (deleteMarketInstrumentRequest?: DeleteMarketInstrumentRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v3/market/instrument/delete`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication SupabaseOAuth2BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            localVarHeaderParameter['Content-Type'] = 'application/json';
            localVarHeaderParameter['Accept'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(deleteMarketInstrumentRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Delete a financial security
         * @summary Delete market security
         * @param {DeleteMarketSecurityRequest} [deleteMarketSecurityRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteMarketSecurity: async (deleteMarketSecurityRequest?: DeleteMarketSecurityRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v3/market/security/delete`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication SupabaseOAuth2BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            localVarHeaderParameter['Content-Type'] = 'application/json';
            localVarHeaderParameter['Accept'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(deleteMarketSecurityRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Disable a market instrument for trading
         * @summary Disable market instrument
         * @param {DisableMarketInstrumentRequest} [disableMarketInstrumentRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        disableMarketInstrument: async (disableMarketInstrumentRequest?: DisableMarketInstrumentRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v3/market/instrument/disable`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication SupabaseOAuth2BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            localVarHeaderParameter['Content-Type'] = 'application/json';
            localVarHeaderParameter['Accept'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(disableMarketInstrumentRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Enable a market instrument for trading
         * @summary Enable market instrument
         * @param {EnableMarketInstrumentRequest} [enableMarketInstrumentRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        enableMarketInstrument: async (enableMarketInstrumentRequest?: EnableMarketInstrumentRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v3/market/instrument/enable`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication SupabaseOAuth2BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            localVarHeaderParameter['Content-Type'] = 'application/json';
            localVarHeaderParameter['Accept'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(enableMarketInstrumentRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get order book for a specific instrument. instrumentId or venue+symbol
         * @summary Get market order book
         * @param {string} [instrumentId] Instrument ID
         * @param {Venue} [venue] Exchange type
         * @param {string} [symbol] Instrument Symbol
         * @param {number} [depth] Order book depth
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMarketOrderBook: async (instrumentId?: string, venue?: Venue, symbol?: string, depth?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v3/market/orderBook/get`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication SupabaseOAuth2BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (instrumentId !== undefined) {
                localVarQueryParameter['instrumentId'] = instrumentId;
            }

            if (venue !== undefined) {
                localVarQueryParameter['venue'] = venue;
            }

            if (symbol !== undefined) {
                localVarQueryParameter['symbol'] = symbol;
            }

            if (depth !== undefined) {
                localVarQueryParameter['depth'] = depth;
            }

            localVarHeaderParameter['Accept'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * List available market instruments
         * @summary List market instruments
         * @param {Venue} [venue] Exchange type
         * @param {Array<string>} [symbols] Instrument Symbols array
         * @param {SecurityType} [securityType] Security type
         * @param {InstrumentStatus} [instrumentStatus] Instrument status
         * @param {number} [limit] Limit the number of returned results
         * @param {number} [offset] Offset of the returned results
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listMarketInstruments: async (venue?: Venue, symbols?: Array<string>, securityType?: SecurityType, instrumentStatus?: InstrumentStatus, limit?: number, offset?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v3/market/instrument/list`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication SupabaseOAuth2BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (venue !== undefined) {
                localVarQueryParameter['venue'] = venue;
            }

            if (symbols) {
                localVarQueryParameter['symbols'] = symbols;
            }

            if (securityType !== undefined) {
                localVarQueryParameter['securityType'] = securityType;
            }

            if (instrumentStatus !== undefined) {
                localVarQueryParameter['instrumentStatus'] = instrumentStatus;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            localVarHeaderParameter['Accept'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * List order books for multiple instruments
         * @summary List market order books
         * @param {Array<string>} [instrumentIds] 
         * @param {Venue} [venue] Exchange type
         * @param {Array<string>} [symbols] Instrument Symbols array
         * @param {number} [depth] Order book depth
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listMarketOrderBooks: async (instrumentIds?: Array<string>, venue?: Venue, symbols?: Array<string>, depth?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v3/market/orderBook/list`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication SupabaseOAuth2BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (instrumentIds) {
                localVarQueryParameter['instrumentIds'] = instrumentIds;
            }

            if (venue !== undefined) {
                localVarQueryParameter['venue'] = venue;
            }

            if (symbols) {
                localVarQueryParameter['symbols'] = symbols;
            }

            if (depth !== undefined) {
                localVarQueryParameter['depth'] = depth;
            }

            localVarHeaderParameter['Accept'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * List available financial securities
         * @summary List market securities
         * @param {Venue} [venue] Exchange type
         * @param {string} [securityId] Security ID
         * @param {number} [limit] Limit the number of returned results
         * @param {number} [offset] Offset of the returned results
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listMarketSecurities: async (venue?: Venue, securityId?: string, limit?: number, offset?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v3/market/security/list`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication SupabaseOAuth2BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (venue !== undefined) {
                localVarQueryParameter['venue'] = venue;
            }

            if (securityId !== undefined) {
                localVarQueryParameter['securityId'] = securityId;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            localVarHeaderParameter['Accept'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * List available market venues/exchanges
         * @summary List market venues
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listMarketVenues: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v3/market/venue/list`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication SupabaseOAuth2BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            localVarHeaderParameter['Accept'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Synchronize market instruments from exchanges
         * @summary Sync market instruments
         * @param {SyncMarketInstrumentsRequest} [syncMarketInstrumentsRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        syncMarketInstruments: async (syncMarketInstrumentsRequest?: SyncMarketInstrumentsRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v3/market/instrument/sync`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication SupabaseOAuth2BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            localVarHeaderParameter['Content-Type'] = 'application/json';
            localVarHeaderParameter['Accept'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(syncMarketInstrumentsRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Synchronize financial securities from exchanges
         * @summary Sync market securities
         * @param {SyncMarketSecuritiesRequest} [syncMarketSecuritiesRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        syncMarketSecurities: async (syncMarketSecuritiesRequest?: SyncMarketSecuritiesRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v3/market/security/sync`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication SupabaseOAuth2BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            localVarHeaderParameter['Content-Type'] = 'application/json';
            localVarHeaderParameter['Accept'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(syncMarketSecuritiesRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * MarketApi - functional programming interface
 */
export const MarketApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = MarketApiAxiosParamCreator(configuration)
    return {
        /**
         * Delete a market instrument
         * @summary Delete market instrument
         * @param {DeleteMarketInstrumentRequest} [deleteMarketInstrumentRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteMarketInstrument(deleteMarketInstrumentRequest?: DeleteMarketInstrumentRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DeleteMarketInstrument200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteMarketInstrument(deleteMarketInstrumentRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['MarketApi.deleteMarketInstrument']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Delete a financial security
         * @summary Delete market security
         * @param {DeleteMarketSecurityRequest} [deleteMarketSecurityRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteMarketSecurity(deleteMarketSecurityRequest?: DeleteMarketSecurityRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DeleteMarketSecurity200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteMarketSecurity(deleteMarketSecurityRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['MarketApi.deleteMarketSecurity']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Disable a market instrument for trading
         * @summary Disable market instrument
         * @param {DisableMarketInstrumentRequest} [disableMarketInstrumentRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async disableMarketInstrument(disableMarketInstrumentRequest?: DisableMarketInstrumentRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<EnableMarketInstrument200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.disableMarketInstrument(disableMarketInstrumentRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['MarketApi.disableMarketInstrument']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Enable a market instrument for trading
         * @summary Enable market instrument
         * @param {EnableMarketInstrumentRequest} [enableMarketInstrumentRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async enableMarketInstrument(enableMarketInstrumentRequest?: EnableMarketInstrumentRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<EnableMarketInstrument200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.enableMarketInstrument(enableMarketInstrumentRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['MarketApi.enableMarketInstrument']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get order book for a specific instrument. instrumentId or venue+symbol
         * @summary Get market order book
         * @param {string} [instrumentId] Instrument ID
         * @param {Venue} [venue] Exchange type
         * @param {string} [symbol] Instrument Symbol
         * @param {number} [depth] Order book depth
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getMarketOrderBook(instrumentId?: string, venue?: Venue, symbol?: string, depth?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetMarketOrderBook200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getMarketOrderBook(instrumentId, venue, symbol, depth, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['MarketApi.getMarketOrderBook']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * List available market instruments
         * @summary List market instruments
         * @param {Venue} [venue] Exchange type
         * @param {Array<string>} [symbols] Instrument Symbols array
         * @param {SecurityType} [securityType] Security type
         * @param {InstrumentStatus} [instrumentStatus] Instrument status
         * @param {number} [limit] Limit the number of returned results
         * @param {number} [offset] Offset of the returned results
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listMarketInstruments(venue?: Venue, symbols?: Array<string>, securityType?: SecurityType, instrumentStatus?: InstrumentStatus, limit?: number, offset?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ListMarketInstruments200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listMarketInstruments(venue, symbols, securityType, instrumentStatus, limit, offset, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['MarketApi.listMarketInstruments']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * List order books for multiple instruments
         * @summary List market order books
         * @param {Array<string>} [instrumentIds] 
         * @param {Venue} [venue] Exchange type
         * @param {Array<string>} [symbols] Instrument Symbols array
         * @param {number} [depth] Order book depth
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listMarketOrderBooks(instrumentIds?: Array<string>, venue?: Venue, symbols?: Array<string>, depth?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ListMarketOrderBooks200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listMarketOrderBooks(instrumentIds, venue, symbols, depth, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['MarketApi.listMarketOrderBooks']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * List available financial securities
         * @summary List market securities
         * @param {Venue} [venue] Exchange type
         * @param {string} [securityId] Security ID
         * @param {number} [limit] Limit the number of returned results
         * @param {number} [offset] Offset of the returned results
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listMarketSecurities(venue?: Venue, securityId?: string, limit?: number, offset?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ListMarketSecurities200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listMarketSecurities(venue, securityId, limit, offset, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['MarketApi.listMarketSecurities']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * List available market venues/exchanges
         * @summary List market venues
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listMarketVenues(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ListMarketVenues200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listMarketVenues(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['MarketApi.listMarketVenues']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Synchronize market instruments from exchanges
         * @summary Sync market instruments
         * @param {SyncMarketInstrumentsRequest} [syncMarketInstrumentsRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async syncMarketInstruments(syncMarketInstrumentsRequest?: SyncMarketInstrumentsRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SyncMarketInstruments200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.syncMarketInstruments(syncMarketInstrumentsRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['MarketApi.syncMarketInstruments']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Synchronize financial securities from exchanges
         * @summary Sync market securities
         * @param {SyncMarketSecuritiesRequest} [syncMarketSecuritiesRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async syncMarketSecurities(syncMarketSecuritiesRequest?: SyncMarketSecuritiesRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DeleteMarketInstrument200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.syncMarketSecurities(syncMarketSecuritiesRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['MarketApi.syncMarketSecurities']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * MarketApi - factory interface
 */
export const MarketApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = MarketApiFp(configuration)
    return {
        /**
         * Delete a market instrument
         * @summary Delete market instrument
         * @param {DeleteMarketInstrumentRequest} [deleteMarketInstrumentRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteMarketInstrument(deleteMarketInstrumentRequest?: DeleteMarketInstrumentRequest, options?: RawAxiosRequestConfig): AxiosPromise<DeleteMarketInstrument200Response> {
            return localVarFp.deleteMarketInstrument(deleteMarketInstrumentRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Delete a financial security
         * @summary Delete market security
         * @param {DeleteMarketSecurityRequest} [deleteMarketSecurityRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteMarketSecurity(deleteMarketSecurityRequest?: DeleteMarketSecurityRequest, options?: RawAxiosRequestConfig): AxiosPromise<DeleteMarketSecurity200Response> {
            return localVarFp.deleteMarketSecurity(deleteMarketSecurityRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Disable a market instrument for trading
         * @summary Disable market instrument
         * @param {DisableMarketInstrumentRequest} [disableMarketInstrumentRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        disableMarketInstrument(disableMarketInstrumentRequest?: DisableMarketInstrumentRequest, options?: RawAxiosRequestConfig): AxiosPromise<EnableMarketInstrument200Response> {
            return localVarFp.disableMarketInstrument(disableMarketInstrumentRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Enable a market instrument for trading
         * @summary Enable market instrument
         * @param {EnableMarketInstrumentRequest} [enableMarketInstrumentRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        enableMarketInstrument(enableMarketInstrumentRequest?: EnableMarketInstrumentRequest, options?: RawAxiosRequestConfig): AxiosPromise<EnableMarketInstrument200Response> {
            return localVarFp.enableMarketInstrument(enableMarketInstrumentRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Get order book for a specific instrument. instrumentId or venue+symbol
         * @summary Get market order book
         * @param {string} [instrumentId] Instrument ID
         * @param {Venue} [venue] Exchange type
         * @param {string} [symbol] Instrument Symbol
         * @param {number} [depth] Order book depth
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMarketOrderBook(instrumentId?: string, venue?: Venue, symbol?: string, depth?: number, options?: RawAxiosRequestConfig): AxiosPromise<GetMarketOrderBook200Response> {
            return localVarFp.getMarketOrderBook(instrumentId, venue, symbol, depth, options).then((request) => request(axios, basePath));
        },
        /**
         * List available market instruments
         * @summary List market instruments
         * @param {Venue} [venue] Exchange type
         * @param {Array<string>} [symbols] Instrument Symbols array
         * @param {SecurityType} [securityType] Security type
         * @param {InstrumentStatus} [instrumentStatus] Instrument status
         * @param {number} [limit] Limit the number of returned results
         * @param {number} [offset] Offset of the returned results
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listMarketInstruments(venue?: Venue, symbols?: Array<string>, securityType?: SecurityType, instrumentStatus?: InstrumentStatus, limit?: number, offset?: number, options?: RawAxiosRequestConfig): AxiosPromise<ListMarketInstruments200Response> {
            return localVarFp.listMarketInstruments(venue, symbols, securityType, instrumentStatus, limit, offset, options).then((request) => request(axios, basePath));
        },
        /**
         * List order books for multiple instruments
         * @summary List market order books
         * @param {Array<string>} [instrumentIds] 
         * @param {Venue} [venue] Exchange type
         * @param {Array<string>} [symbols] Instrument Symbols array
         * @param {number} [depth] Order book depth
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listMarketOrderBooks(instrumentIds?: Array<string>, venue?: Venue, symbols?: Array<string>, depth?: number, options?: RawAxiosRequestConfig): AxiosPromise<ListMarketOrderBooks200Response> {
            return localVarFp.listMarketOrderBooks(instrumentIds, venue, symbols, depth, options).then((request) => request(axios, basePath));
        },
        /**
         * List available financial securities
         * @summary List market securities
         * @param {Venue} [venue] Exchange type
         * @param {string} [securityId] Security ID
         * @param {number} [limit] Limit the number of returned results
         * @param {number} [offset] Offset of the returned results
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listMarketSecurities(venue?: Venue, securityId?: string, limit?: number, offset?: number, options?: RawAxiosRequestConfig): AxiosPromise<ListMarketSecurities200Response> {
            return localVarFp.listMarketSecurities(venue, securityId, limit, offset, options).then((request) => request(axios, basePath));
        },
        /**
         * List available market venues/exchanges
         * @summary List market venues
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listMarketVenues(options?: RawAxiosRequestConfig): AxiosPromise<ListMarketVenues200Response> {
            return localVarFp.listMarketVenues(options).then((request) => request(axios, basePath));
        },
        /**
         * Synchronize market instruments from exchanges
         * @summary Sync market instruments
         * @param {SyncMarketInstrumentsRequest} [syncMarketInstrumentsRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        syncMarketInstruments(syncMarketInstrumentsRequest?: SyncMarketInstrumentsRequest, options?: RawAxiosRequestConfig): AxiosPromise<SyncMarketInstruments200Response> {
            return localVarFp.syncMarketInstruments(syncMarketInstrumentsRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Synchronize financial securities from exchanges
         * @summary Sync market securities
         * @param {SyncMarketSecuritiesRequest} [syncMarketSecuritiesRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        syncMarketSecurities(syncMarketSecuritiesRequest?: SyncMarketSecuritiesRequest, options?: RawAxiosRequestConfig): AxiosPromise<DeleteMarketInstrument200Response> {
            return localVarFp.syncMarketSecurities(syncMarketSecuritiesRequest, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * MarketApi - object-oriented interface
 */
export class MarketApi extends BaseAPI {
    /**
     * Delete a market instrument
     * @summary Delete market instrument
     * @param {DeleteMarketInstrumentRequest} [deleteMarketInstrumentRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public deleteMarketInstrument(deleteMarketInstrumentRequest?: DeleteMarketInstrumentRequest, options?: RawAxiosRequestConfig) {
        return MarketApiFp(this.configuration).deleteMarketInstrument(deleteMarketInstrumentRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Delete a financial security
     * @summary Delete market security
     * @param {DeleteMarketSecurityRequest} [deleteMarketSecurityRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public deleteMarketSecurity(deleteMarketSecurityRequest?: DeleteMarketSecurityRequest, options?: RawAxiosRequestConfig) {
        return MarketApiFp(this.configuration).deleteMarketSecurity(deleteMarketSecurityRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Disable a market instrument for trading
     * @summary Disable market instrument
     * @param {DisableMarketInstrumentRequest} [disableMarketInstrumentRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public disableMarketInstrument(disableMarketInstrumentRequest?: DisableMarketInstrumentRequest, options?: RawAxiosRequestConfig) {
        return MarketApiFp(this.configuration).disableMarketInstrument(disableMarketInstrumentRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Enable a market instrument for trading
     * @summary Enable market instrument
     * @param {EnableMarketInstrumentRequest} [enableMarketInstrumentRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public enableMarketInstrument(enableMarketInstrumentRequest?: EnableMarketInstrumentRequest, options?: RawAxiosRequestConfig) {
        return MarketApiFp(this.configuration).enableMarketInstrument(enableMarketInstrumentRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get order book for a specific instrument. instrumentId or venue+symbol
     * @summary Get market order book
     * @param {string} [instrumentId] Instrument ID
     * @param {Venue} [venue] Exchange type
     * @param {string} [symbol] Instrument Symbol
     * @param {number} [depth] Order book depth
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public getMarketOrderBook(instrumentId?: string, venue?: Venue, symbol?: string, depth?: number, options?: RawAxiosRequestConfig) {
        return MarketApiFp(this.configuration).getMarketOrderBook(instrumentId, venue, symbol, depth, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * List available market instruments
     * @summary List market instruments
     * @param {Venue} [venue] Exchange type
     * @param {Array<string>} [symbols] Instrument Symbols array
     * @param {SecurityType} [securityType] Security type
     * @param {InstrumentStatus} [instrumentStatus] Instrument status
     * @param {number} [limit] Limit the number of returned results
     * @param {number} [offset] Offset of the returned results
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public listMarketInstruments(venue?: Venue, symbols?: Array<string>, securityType?: SecurityType, instrumentStatus?: InstrumentStatus, limit?: number, offset?: number, options?: RawAxiosRequestConfig) {
        return MarketApiFp(this.configuration).listMarketInstruments(venue, symbols, securityType, instrumentStatus, limit, offset, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * List order books for multiple instruments
     * @summary List market order books
     * @param {Array<string>} [instrumentIds] 
     * @param {Venue} [venue] Exchange type
     * @param {Array<string>} [symbols] Instrument Symbols array
     * @param {number} [depth] Order book depth
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public listMarketOrderBooks(instrumentIds?: Array<string>, venue?: Venue, symbols?: Array<string>, depth?: number, options?: RawAxiosRequestConfig) {
        return MarketApiFp(this.configuration).listMarketOrderBooks(instrumentIds, venue, symbols, depth, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * List available financial securities
     * @summary List market securities
     * @param {Venue} [venue] Exchange type
     * @param {string} [securityId] Security ID
     * @param {number} [limit] Limit the number of returned results
     * @param {number} [offset] Offset of the returned results
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public listMarketSecurities(venue?: Venue, securityId?: string, limit?: number, offset?: number, options?: RawAxiosRequestConfig) {
        return MarketApiFp(this.configuration).listMarketSecurities(venue, securityId, limit, offset, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * List available market venues/exchanges
     * @summary List market venues
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public listMarketVenues(options?: RawAxiosRequestConfig) {
        return MarketApiFp(this.configuration).listMarketVenues(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Synchronize market instruments from exchanges
     * @summary Sync market instruments
     * @param {SyncMarketInstrumentsRequest} [syncMarketInstrumentsRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public syncMarketInstruments(syncMarketInstrumentsRequest?: SyncMarketInstrumentsRequest, options?: RawAxiosRequestConfig) {
        return MarketApiFp(this.configuration).syncMarketInstruments(syncMarketInstrumentsRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Synchronize financial securities from exchanges
     * @summary Sync market securities
     * @param {SyncMarketSecuritiesRequest} [syncMarketSecuritiesRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public syncMarketSecurities(syncMarketSecuritiesRequest?: SyncMarketSecuritiesRequest, options?: RawAxiosRequestConfig) {
        return MarketApiFp(this.configuration).syncMarketSecurities(syncMarketSecuritiesRequest, options).then((request) => request(this.axios, this.basePath));
    }
}

